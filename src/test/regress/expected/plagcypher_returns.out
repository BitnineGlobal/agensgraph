--
-- PL/agCypher - Use Parameter
--
-- setup
drop graph if exists g2 cascade;
NOTICE:  graph "g2" does not exist, skipping
drop function if exists returns_vertex();
NOTICE:  function returns_vertex() does not exist, skipping
drop function if exists returns_edge();
NOTICE:  function returns_edge() does not exist, skipping
drop function if exists returns_graphpath();
NOTICE:  function returns_graphpath() does not exist, skipping
drop function if exists returns_graphid();
NOTICE:  function returns_graphid() does not exist, skipping
create graph g2;
set graph_path=g2;
create (:person{name : 'Anders'}), (:person{name : 'Dilshad'}), (:person{name : 'Cesar'}), (:person{name : 'Becky'}), (:person{name : 'Filipa'}), (:person{name : 'Emil'});
match (a), (b)
where a.name = 'Anders' and b.name = 'Dilshad'
create (a)-[e:knows{name:'friend1'}]->(b)
return e;
                   e                    
----------------------------------------
 knows[4.1][3.1,3.2]{"name": "friend1"}
(1 row)

match (a), (b)
where a.name = 'Anders' and b.name = 'Cesar'
create (a)-[e:knows{name:'friend2'}]->(b)
return e;
                   e                    
----------------------------------------
 knows[4.2][3.1,3.3]{"name": "friend2"}
(1 row)

match (a), (b)
where a.name = 'Anders' and b.name = 'Becky'
create (a)-[e:knows{name:'friend3'}]->(b)
return e;
                   e                    
----------------------------------------
 knows[4.3][3.1,3.4]{"name": "friend3"}
(1 row)

match (a), (b)
where a.name = 'Dilshad' and b.name = 'Filipa'
create (a)-[e:knows{name:'friend4'}]->(b)
return e;
                   e                    
----------------------------------------
 knows[4.4][3.2,3.5]{"name": "friend4"}
(1 row)

match (a), (b)
where a.name = 'Cesar' and b.name = 'Emil'
create (a)-[e:knows{name:'friend5'}]->(b)
return e;
                   e                    
----------------------------------------
 knows[4.5][3.3,3.6]{"name": "friend5"}
(1 row)

match (a), (b)
where a.name = 'Becky' and b.name = 'Emil'
create (a)-[e:knows{name:'friend6'}]->(b)
return e;
                   e                    
----------------------------------------
 knows[4.6][3.4,3.6]{"name": "friend6"}
(1 row)

-- test returns( vertex )
create or replace function returns_vertex() returns vertex as $$
declare
var1 vertex;
begin
match (x)-[z]->(y) where z.name = 'friend2' and y.name = 'Cesar' return x into var1;
return var1;
end;
$$ language plagcypher;
select returns_vertex();
        returns_vertex         
-------------------------------
 person[3.1]{"name": "Anders"}
(1 row)

-- test returns( edge )
create or replace function returns_edge() returns edge as $$
declare
var1 edge;
begin
match (x)-[z]->(y) where x.name = 'Dilshad' and y.name = 'Filipa' return z into var1;
return var1;
end;
$$ language plagcypher;
select returns_edge();
              returns_edge              
----------------------------------------
 knows[4.4][3.2,3.5]{"name": "friend4"}
(1 row)

-- test returns( graphpath )
create or replace function returns_graphpath() returns graphpath as $$
declare
var1 graphpath;
begin
match p=allshortestpaths( (n)-[*..4]-(m) ) where n.name = 'Dilshad' and m.name = 'Filipa' return p into var1;
return var1;
end;
$$ language plagcypher;
select returns_graphpath();
                                           returns_graphpath                                           
-------------------------------------------------------------------------------------------------------
 [person[3.2]{"name": "Dilshad"},knows[4.4][3.2,3.5]{"name": "friend4"},person[3.5]{"name": "Filipa"}]
(1 row)

-- test returns( graphid )
create or replace function returns_graphid() returns graphid as $$
declare
var1 graphid;
begin
match (x)-[z]-(y) where x.name = 'Emil' and y.name = 'Cesar' return id(z) into var1;
return var1;
end;
$$ language plagcypher;
select returns_graphid();
 returns_graphid 
-----------------
 4.5
(1 row)

-- cleanup
drop function if exists returns_graphid();
drop function if exists returns_graphpath();
drop function if exists returns_edge();
drop function if exists returns_vertex();
drop graph if exists g2 cascade;
NOTICE:  drop cascades to 5 other objects
DETAIL:  drop cascades to sequence g2.ag_label_seq
drop cascades to vlabel ag_vertex
drop cascades to elabel ag_edge
drop cascades to vlabel person
drop cascades to elabel knows
