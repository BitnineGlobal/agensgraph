CREATE GRAPH cypher_dml2;
CREATE VLABEL v1;
EXPLAIN ( analyze false, verbose true, costs false, buffers false, timing false )
MATCH (p:v1)
return max(collect(p.name)) as col;
ERROR:  aggregate function calls cannot be nested
LINE 3: return max(collect(p.name)) as col;
                   ^
MATCH (p:v1)
return max(collect(p.name)) as col;
ERROR:  aggregate function calls cannot be nested
LINE 2: return max(collect(p.name)) as col;
                   ^
MATCH (p:v1)
with collect(p.name) as col
RETURN max(col);
 max 
-----
 
(1 row)

CREATE ELABEL e1;
-- AGV2-29, Predicates functions want jsonb, not list
MATCH p=(n1)-[r:e1*2]->(n2)
WHERE all(x in r where x.id is null)
RETURN count(p);
 count 
-------
 0
(1 row)

-- AGV2-26, head/tail/last returns array
CREATE(:v_user{name:'userA'});
CREATE(:v_title{name:'TitleA'});
CREATE(:v_type{name:'TypeA'});
CREATE(:v_sub{name:'SubA'});
MATCH(v1:v_user{name:'userA'}), (v2:v_title{name:'TitleA'})
CREATE (v1)-[:e_user_title{name:'(1)', val:1}]->(v2);
MATCH(v1:v_title{name:'TitleA'}), (v2:v_type{name:'TypeA'})
CREATE (v1)-[:e_title_type{name:'(2)', val:2}]->(v2);
MATCH(v1:v_type{name:'TypeA'}), (v2:v_sub{name:'SubA'})
CREATE (v1)-[:e_title_type{name:'(3)', val:3}]->(v2);
MATCH(n)-[e*3]->(n3) RETURN e;
                                                                                e                                                                                
-----------------------------------------------------------------------------------------------------------------------------------------------------------------
 [e_user_title[9.1][5.1,6.1]{"val": 1, "name": "(1)"},e_title_type[10.1][6.1,7.1]{"val": 2, "name": "(2)"},e_title_type[10.2][7.1,8.1]{"val": 3, "name": "(3)"}]
(1 row)

MATCH(n)-[e*3]->(n3) RETURN head(e);
                        head                         
-----------------------------------------------------
 e_user_title[9.1][5.1,6.1]{"val": 1, "name": "(1)"}
(1 row)

MATCH(n)-[e*3]->(n3) RETURN tail(e);
                                                    tail                                                     
-------------------------------------------------------------------------------------------------------------
 [e_title_type[10.1][6.1,7.1]{"val": 2, "name": "(2)"},e_title_type[10.2][7.1,8.1]{"val": 3, "name": "(3)"}]
(1 row)

MATCH(n)-[e*3]->(n3) RETURN last(e);
                         last                         
------------------------------------------------------
 e_title_type[10.2][7.1,8.1]{"val": 3, "name": "(3)"}
(1 row)

DROP GRAPH cypher_dml2 CASCADE;
NOTICE:  drop cascades to 11 other objects
DETAIL:  drop cascades to sequence cypher_dml2.ag_label_seq
drop cascades to vlabel ag_vertex
drop cascades to elabel ag_edge
drop cascades to vlabel v1
drop cascades to elabel e1
drop cascades to vlabel v_user
drop cascades to vlabel v_title
drop cascades to vlabel v_type
drop cascades to vlabel v_sub
drop cascades to elabel e_user_title
drop cascades to elabel e_title_type
CREATE GRAPH cypher_dml2;
SET GRAPH_PATH to cypher_dml2;
CREATE ({id: 1})-[:e1]->({id: 2})-[:e1]->({id: 3})-[:e1]->({id: 4})
RETURN *;
        ?column?         |      ?column?      |        ?column?         |      ?column?      |        ?column?         |      ?column?      |        ?column?         
-------------------------+--------------------+-------------------------+--------------------+-------------------------+--------------------+-------------------------
 ag_vertex[1.1]{"id": 1} | e1[3.1][1.1,1.2]{} | ag_vertex[1.2]{"id": 2} | e1[3.2][1.2,1.3]{} | ag_vertex[1.3]{"id": 3} | e1[3.3][1.3,1.4]{} | ag_vertex[1.4]{"id": 4}
(1 row)

MATCH (a {id: 1}), (b {id: 1})
CREATE (b)-[:e1]->(a)
RETURN *;
            a            |            b            |      ?column?      
-------------------------+-------------------------+--------------------
 ag_vertex[1.1]{"id": 1} | ag_vertex[1.1]{"id": 1} | e1[3.4][1.1,1.1]{}
(1 row)

MATCH (a)
RETURN *;
            a            
-------------------------
 ag_vertex[1.1]{"id": 1}
 ag_vertex[1.2]{"id": 2}
 ag_vertex[1.3]{"id": 3}
 ag_vertex[1.4]{"id": 4}
(4 rows)

MATCH (a)-[]-(a) RETURN *;
            a            
-------------------------
 ag_vertex[1.1]{"id": 1}
 ag_vertex[1.1]{"id": 1}
(2 rows)

MATCH p=(a)-[]-(a) RETURN *;
            a            |                                  p                                   
-------------------------+----------------------------------------------------------------------
 ag_vertex[1.1]{"id": 1} | [ag_vertex[1.1]{"id": 1},e1[3.4][1.1,1.1]{},ag_vertex[1.1]{"id": 1}]
 ag_vertex[1.1]{"id": 1} | [ag_vertex[1.1]{"id": 1},e1[3.4][1.1,1.1]{},ag_vertex[1.1]{"id": 1}]
(2 rows)

EXPLAIN VERBOSE MATCH (a)-[]-(a) RETURN a;
                                           QUERY PLAN                                           
------------------------------------------------------------------------------------------------
 Hash Join  (cost=44.46..71.08 rows=12 width=32)
   Output: ROW(a.id, a.properties, a.ctid)::vertex
   Hash Cond: (a.id = ag_edge.start)
   ->  Seq Scan on cypher_dml2.ag_vertex a  (cost=0.00..22.00 rows=1200 width=46)
         Output: a.id, a.properties, a.ctid
   ->  Hash  (cost=44.31..44.31 rows=12 width=16)
         Output: ag_edge.start, ag_edge."end"
         ->  Append  (cost=0.00..44.31 rows=12 width=16)
               ->  Seq Scan on cypher_dml2.ag_edge  (cost=0.00..0.00 rows=1 width=16)
                     Output: ag_edge.start, ag_edge."end"
                     Filter: (ag_edge.start = ag_edge."end")
               ->  Seq Scan on cypher_dml2.e1 ag_edge_1  (cost=0.00..22.12 rows=5 width=16)
                     Output: ag_edge_1.start, ag_edge_1."end"
                     Filter: (ag_edge_1.start = ag_edge_1."end")
               ->  Seq Scan on cypher_dml2.ag_edge ag_edge_2  (cost=0.00..0.00 rows=1 width=16)
                     Output: ag_edge_2."end", ag_edge_2.start
                     Filter: (ag_edge_2."end" = ag_edge_2.start)
               ->  Seq Scan on cypher_dml2.e1 ag_edge_3  (cost=0.00..22.12 rows=5 width=16)
                     Output: ag_edge_3."end", ag_edge_3.start
                     Filter: (ag_edge_3."end" = ag_edge_3.start)
(20 rows)

EXPLAIN VERBOSE MATCH (a)-[]-(a) RETURN *;
                                           QUERY PLAN                                           
------------------------------------------------------------------------------------------------
 Hash Join  (cost=44.46..71.08 rows=12 width=32)
   Output: ROW(a.id, a.properties, a.ctid)::vertex
   Hash Cond: (a.id = ag_edge.start)
   ->  Seq Scan on cypher_dml2.ag_vertex a  (cost=0.00..22.00 rows=1200 width=46)
         Output: a.id, a.properties, a.ctid
   ->  Hash  (cost=44.31..44.31 rows=12 width=16)
         Output: ag_edge.start, ag_edge."end"
         ->  Append  (cost=0.00..44.31 rows=12 width=16)
               ->  Seq Scan on cypher_dml2.ag_edge  (cost=0.00..0.00 rows=1 width=16)
                     Output: ag_edge.start, ag_edge."end"
                     Filter: (ag_edge.start = ag_edge."end")
               ->  Seq Scan on cypher_dml2.e1 ag_edge_1  (cost=0.00..22.12 rows=5 width=16)
                     Output: ag_edge_1.start, ag_edge_1."end"
                     Filter: (ag_edge_1.start = ag_edge_1."end")
               ->  Seq Scan on cypher_dml2.ag_edge ag_edge_2  (cost=0.00..0.00 rows=1 width=16)
                     Output: ag_edge_2."end", ag_edge_2.start
                     Filter: (ag_edge_2."end" = ag_edge_2.start)
               ->  Seq Scan on cypher_dml2.e1 ag_edge_3  (cost=0.00..22.12 rows=5 width=16)
                     Output: ag_edge_3."end", ag_edge_3.start
                     Filter: (ag_edge_3."end" = ag_edge_3.start)
(20 rows)

EXPLAIN VERBOSE MATCH p=(a)-[]-(a) RETURN *;
                                                                                                                                      QUERY PLAN                                                                                                                                      
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Hash Join  (cost=44.46..71.17 rows=12 width=64)
   Output: ROW(a.id, a.properties, a.ctid)::vertex, ROW((('[]'::vertex[] || ROW(a.id, a.properties, a.ctid)::vertex) || ROW(a.id, a.properties, a.ctid)::vertex), ('[]'::edge[] || ROW(ag_edge.id, ag_edge.start, ag_edge."end", ag_edge.properties, ag_edge.ctid)::edge))::graphpath
   Hash Cond: (a.id = ag_edge.start)
   ->  Seq Scan on cypher_dml2.ag_vertex a  (cost=0.00..22.00 rows=1200 width=46)
         Output: a.id, a.properties, a.ctid
   ->  Hash  (cost=44.31..44.31 rows=12 width=78)
         Output: ag_edge.id, ag_edge.start, ag_edge."end", ag_edge.properties, ag_edge.ctid, ag_edge.start, ag_edge."end"
         ->  Append  (cost=0.00..44.31 rows=12 width=78)
               ->  Seq Scan on cypher_dml2.ag_edge  (cost=0.00..0.00 rows=1 width=78)
                     Output: ag_edge.id, ag_edge.start, ag_edge."end", ag_edge.properties, ag_edge.ctid, ag_edge.start, ag_edge."end"
                     Filter: (ag_edge.start = ag_edge."end")
               ->  Seq Scan on cypher_dml2.e1 ag_edge_1  (cost=0.00..22.12 rows=5 width=78)
                     Output: ag_edge_1.id, ag_edge_1.start, ag_edge_1."end", ag_edge_1.properties, ag_edge_1.ctid, ag_edge_1.start, ag_edge_1."end"
                     Filter: (ag_edge_1.start = ag_edge_1."end")
               ->  Seq Scan on cypher_dml2.ag_edge ag_edge_2  (cost=0.00..0.00 rows=1 width=78)
                     Output: ag_edge_2.id, ag_edge_2.start, ag_edge_2."end", ag_edge_2.properties, ag_edge_2.ctid, ag_edge_2."end", ag_edge_2.start
                     Filter: (ag_edge_2."end" = ag_edge_2.start)
               ->  Seq Scan on cypher_dml2.e1 ag_edge_3  (cost=0.00..22.12 rows=5 width=78)
                     Output: ag_edge_3.id, ag_edge_3.start, ag_edge_3."end", ag_edge_3.properties, ag_edge_3.ctid, ag_edge_3."end", ag_edge_3.start
                     Filter: (ag_edge_3."end" = ag_edge_3.start)
(20 rows)

DROP GRAPH cypher_dml2 CASCADE;
NOTICE:  drop cascades to 4 other objects
DETAIL:  drop cascades to sequence cypher_dml2.ag_label_seq
drop cascades to vlabel ag_vertex
drop cascades to elabel ag_edge
drop cascades to elabel e1
