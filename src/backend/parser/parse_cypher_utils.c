/*
 * parse_cypher_utils.c
 *
 * Copyright (c) 2022 by Bitnine Global, Inc.
 *
 * IDENTIFICATION
 *	  src/include/parser/parse_cypher_utils.c
 */

#include "postgres.h"

#include "access/relscan.h"
#include "catalog/ag_label.h"
#include "nodes/makefuncs.h"
#include "parser/parse_cypher_utils.h"
#include "parser/parse_relation.h"
#include "utils/lsyscache.h"
#include "utils/syscache.h"
#include "catalog/pg_type.h"

/*
 * Copy from `expandRelAttrs`
 */
List *expandRelAttrsForCypher(ParseState *pstate, RangeTblEntry *rte,
                              int rtindex, int sublevels_up, int location)
{
	List *names, *vars;
	ListCell *name, *var;
	List *te_list = NIL;

	expandRTE(rte, rtindex, sublevels_up, location, false,
	          &names, &vars);

	/*
	 * Require read access to the table.  This is normally redundant with the
	 * markVarForSelectPriv calls below, but not if the table has zero
	 * columns.
	 */
	rte->requiredPerms |= ACL_SELECT;

	forboth(name, names, var, vars)
	{
		char *label = strVal(lfirst(name));
		Var *varnode = (Var *) lfirst(var);
		TargetEntry *te;

		/*
		 * It will ignore original properties.
		 */
		if (IsOriginalPropertiesAlias(label))
		{
			continue;
		}

		te = makeTargetEntry((Expr *) varnode,
		                     (AttrNumber) pstate->p_next_resno++,
		                     label,
		                     false);
		te_list = lappend(te_list, te);

		/* Require read access to each column */
		markVarForSelectPriv(pstate, varnode, rte);
	}

	Assert(name == NULL && var == NULL);	/* lists not the same length? */

	return te_list;
}

static void UnwrapRowAccess(ParseState *pstate, Node **expr)
{
	/*
	 * In Update syntax such as Set, continuous updates do not work if you use
	 * the original properties.
	 */
	if(pstate->p_expr_kind == EXPR_KIND_UPDATE_SOURCE)
		return;

	/*
	 * In the case of FieldSelect, it is highly likely that RowExpr was used.
	 * Therefore, using the TargetEntry generated by "transformMatchNode" in
	 * "parse_graph.c", point it to the original Properties.
	 */
	if (IsA(*expr, FieldSelect))
	{
		FieldSelect *fieldSelect = (FieldSelect *) *expr;
		if (IsA(fieldSelect->arg, Var))
		{
			Var *var = (Var *) fieldSelect->arg;
			if (var->varlevelsup == 0)
			{
				RangeTblEntry *rte = GetRTEByRangeTablePosn(pstate,
															(int) var->varno,
															0);
				if(rte->rtekind == RTE_SUBQUERY && rte->subquery->targetList->length > var->varattno)
				{
					TargetEntry *cur_target = list_nth(rte->subquery->targetList, var->varattno - 1);
					if (IsA(cur_target->expr, RowExpr))
					{
						TargetEntry *next_target = list_nth(rte->subquery->targetList, var->varattno);
						if (next_target && IsOriginalPropertiesAlias(next_target->resname))
						{
							if (IsA(next_target->expr, Var))
							{
								Var *next_var = (Var *) next_target->expr;
								*expr = (Node *) makeVar(var->varno,
								                         (AttrNumber) (var->varattno + 1),
								                         next_var->vartype,
								                         next_var->vartypmod,
								                         next_var->varcollid,
								                         next_var->varlevelsup);
							}
						}
					}
				}
			}
		}
	}
}

Node *makeJsonbFuncAccessor(ParseState *pstate, Node *expr, List *path)
{
	CypherAccessExpr *a = makeNode(CypherAccessExpr);
	UnwrapRowAccess(pstate, &expr);
	a->arg = (Expr *) expr;
	a->path = path;

	return (Node *) a;
}

bool IsJsonbAccessor(Node *expr)
{
	if (IsA(expr, CypherAccessExpr))
	{
		return true;
	}

	return false;
}

void getAccessorArguments(Node *node, Node **expr, List **path)
{
	if (IsA(node, CypherAccessExpr))
	{
		CypherAccessExpr *a = (CypherAccessExpr *) node;

		*expr = (Node *) a->arg;
		*path = a->path;
	}
	else
	{
		elog(ERROR, "cannot extract elements from node");
	}
}

char *MakeIgnorePropertiesAlias(const char* alias)
{
	return psprintf("__ignore__%s__ignore__", alias);
}

bool IsOriginalPropertiesAlias(const char* alias)
{
	const char prefix[] = "__ignore__"; // 10 length word
	int idx = 0;

	while (*(prefix + idx) != 0)
	{
		// prefix is right?
		if (idx < 10 && prefix[idx] != *(alias + idx))
		{
			return false;
		}
		else if (idx >= 10)
		{
			break;
		}
		idx++;
	}
	return true;
}

/*
 * When use PROPERTY INDEX, there is no way to specify original column
 * reference, so make vertex_id, edge_start, and edge_end in the form of
 * reserved words to create a way to specify B.
 */
bool ConvertReservedColumnRefForIndex(Node *node, Oid relid)
{
	Form_ag_label labtup;
	Oid laboid = get_relid_laboid(relid);
	HeapTuple tuple = SearchSysCache1(LABELOID, ObjectIdGetDatum(laboid));
	bool isVertex;

	if (!HeapTupleIsValid(tuple))
		elog(ERROR, "cache lookup failed for label (OID=%u)", laboid);

	labtup = (Form_ag_label) GETSTRUCT(tuple);
	isVertex = (labtup->labkind == LABEL_KIND_VERTEX);
	ReleaseSysCache(tuple);

	if (IsA(node, ColumnRef))
	{
		ColumnRef *columnRef = (ColumnRef *) node;
		if (columnRef->fields->length == 1)
		{
			Node *field_name = linitial(columnRef->fields);
			if (IsA(field_name, String))
			{
				char *fieldStr = strVal(field_name);
				if (isVertex && (strcmp(fieldStr, "vertex_id") == 0))
				{
					columnRef->fields = list_make1(makeString("id"));
					return true;
				}
				else if (!isVertex && strcmp(fieldStr, "edge_start") == 0)
				{
					columnRef->fields = list_make1(makeString("start"));
					return true;
				}
				else if (!isVertex && strcmp(fieldStr, "edge_end") == 0)
				{
					columnRef->fields = list_make1(makeString("end"));
					return true;
				}
			}
		}
	}

	return false;
}